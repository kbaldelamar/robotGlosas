# automation/procesador_en_pausa_especifico.py
"""
Procesador ESPEC√çFICO para m√≥dulo EN PAUSA.
Se mantiene en la secci√≥n "En Pausa" sin navegar a "Bolsa Respuesta".
"""

import asyncio
import logging
from typing import List, Dict, Tuple, Optional
from playwright.async_api import Page
from database.db_manager_glosas import DatabaseManagerGlosas
from database.models_glosas import EstadoCuenta
from automation.navigation_handler import AutomationState
import os 
import traceback



class ProcesadorEnPausaEspecifico:
    """
    Procesador espec√≠fico para m√≥dulo EN PAUSA.
    NO navega a Bolsa Respuesta - se mantiene en En Pausa.
    """
    
    def __init__(self, page: Page, automation_state: AutomationState, worker_thread=None):
        self.page = page
        self.state = automation_state
        self.logger = logging.getLogger(__name__)
        self.db_manager = DatabaseManagerGlosas()
        self.worker = worker_thread

                # ‚úÖ NUEVO: Inicializar configuraciones vac√≠as
        self.configuraciones_respuesta = {}

        # ‚úÖ MANTENER: Selectores espec√≠ficos para EN PAUSA
        self.selectores = {
            'filas_tabla_principal': "#tablaRespuestaGlosaPause tbody tr",
            'boton_cuenta': ".btRespuestaStart",
            'tabla_glosas': "#tableAuditGlosas",
            'filas_glosas': "#tableAuditGlosas tbody tr",
            'boton_glosa_individual': ".btnAnswerGlosaModal",
            'modal_titulo': "#titleModalAnswerGlosa",
            'form_modal': "#formAnswerGlosa",
            'select2_container': "#select2-glosaRespTipo-container",
            'textarea_justificacion': "#glosaRespObs",
            'input_archivo': "#glosaRespFile",
            'boton_responder': "#btnAnswerGlosa",
            'boton_terminar': "#btRespuestaFinish",
            'boton_confirmar_terminar': ".swal2-confirm",
            'campo_tipo_glosa': "#glosaTipo",
            'campo_justificacion_glosa': "#glosaJustificacion"
        }

        # Selector para las filas de la tabla EN PAUSA (ajusta seg√∫n tu HTML real)
        self.url_tabla_principal = "https://vco.ctamedicas.com/app/respuestaGlosaPause"

        self.url_tabla_en_pausa = None
        
        self.state.update(
            class_name="ProcesadorEnPausaEspecifico",
            method_name="__init__"
        )
        self._log("[CORREGIDO] ProcesadorEnPausaEspecifico inicializado con procesador heredado")
    
    def _log(self, mensaje: str, nivel: str = "info"):
        """Log con informaci√≥n de estado."""
        info_estado = f"[{self.state.current_class}.{self.state.current_method}]"
        mensaje_completo = f"{info_estado} {mensaje}"
        
        if nivel == "info":
            self.logger.info(mensaje_completo)
        elif nivel == "warning":
            self.logger.warning(mensaje_completo)
        elif nivel == "error":
            self.logger.error(mensaje_completo)
    
 
    
    async def procesar_cuentas_en_pausa(self, cuentas_en_pausa: List[Dict]) -> Tuple[int, int]:
        """Procesa las cuentas en pausa usando implementaci√≥n independiente."""
        try:
            self.state.update(
                method_name="procesar_cuentas_en_pausa",
                action="Procesando cuentas en pausa de forma independiente"
            )
            self._log(f"üîÑ Procesando {len(cuentas_en_pausa)} cuentas EN PAUSA (INDEPENDIENTE)")
            
            # Preparar sistema independiente
            if not await self._preparar_sistema():
                return 0, 0

            procesadas = 0
            fallidas = 0

            for i, cuenta_data in enumerate(cuentas_en_pausa):
                idcuenta = cuenta_data['idcuenta']
                intentos_actuales = cuenta_data.get('intentos', 0)

                self._log(f"üéØ PROCESANDO {i + 1}/{len(cuentas_en_pausa)}: {idcuenta}")

                try:
                    # L√≠mite de intentos
                    if intentos_actuales >= 5:
                        self._log(f"üö´ Cuenta {idcuenta} excede 5 intentos, saltando")
                        fallidas += 1
                        continue
                    
                    # Incrementar intentos
                    await self._incrementar_intentos(idcuenta)

                    # Hacer clic en cuenta EN PAUSA
                    if not await self._hacer_clic_cuenta_en_pausa(idcuenta):
                        self._log(f"‚ùå No se pudo hacer clic en cuenta {idcuenta}")
                        fallidas += 1
                        continue
                    
                    # Procesar con implementaci√≥n independiente
                    resultado = await self._procesar_cuenta_completa_independiente(idcuenta)

                    if resultado['exito']:
                        procesadas += 1
                        self._log(f"‚úÖ CUENTA {idcuenta} COMPLETADA")
                        if self.worker:
                            self.worker.emit_cuenta_processed(idcuenta, 'COMPLETADO')
                    else:
                        fallidas += 1
                        if self.worker:
                            self.worker.emit_cuenta_processed(idcuenta, 'FALLIDO')

                except Exception as e:
                    fallidas += 1
                    await self._marcar_error_procesamiento(idcuenta, f"Error general: {e}")
                    self._log(f"‚ùå Error procesando {idcuenta}: {e}", "error")

                # Regresar a tabla principal despu√©s de cada cuenta
                await self._regresar_tabla_principal()
                await asyncio.sleep(3)
                await self._configurar_tabla_500_registros()
                await asyncio.sleep(2)

            return procesadas, fallidas

        except Exception as e:
            self._log(f"‚ùå Error en procesamiento EN PAUSA independiente: {e}", "error")
            return 0, 0

    async def procesar_cuentas_en_pausa_especificas(self, cuentas_en_pausa: List[Dict]) -> Tuple[int, int]:
        """REFACTORIZADO: Usar procesar_cuentas_en_pausa en lugar de l√≥gica propia."""
        return await self.procesar_cuentas_en_pausa(cuentas_en_pausa)

    def _debug_metodos_heredados(self):
        """
        üîç DEBUG: Mostrar m√©todos disponibles de la clase padre.
        """
        try:
            self._log("üîç === DEBUGGING M√âTODOS HEREDADOS ===")

            # Obtener todos los m√©todos disponibles
            metodos_disponibles = []
            for nombre in dir(self):
                if not nombre.startswith('_') and callable(getattr(self, nombre)):
                    metodos_disponibles.append(nombre)

            # Filtrar m√©todos relevantes para procesamiento
            palabras_clave = ['proces', 'glosa', 'ejecutar', 'run', 'handle', 'manage', 'completa']
            metodos_procesamiento = []

            for metodo in metodos_disponibles:
                for palabra in palabras_clave:
                    if palabra.lower() in metodo.lower():
                        metodos_procesamiento.append(metodo)
                        break
                    
            self._log(f"üìã M√©todos de procesamiento disponibles ({len(metodos_procesamiento)}):")
            for metodo in metodos_procesamiento:
                self._log(f"   ‚Ä¢ {metodo}")

            # Verificar m√©todos espec√≠ficos comunes
            metodos_comunes = [
                'procesar_cuenta_completa',
                'procesar_glosas_cuenta', 
                'ejecutar_procesamiento',
                'run_automation',
                'process_account',
                'handle_account',
                '_procesar_cuenta_completa',
                'procesar_glosas',
                'ejecutar_glosas',
                'manejar_glosas'
            ]

            self._log("üéØ Verificando m√©todos comunes:")
            metodos_encontrados = []
            for metodo in metodos_comunes:
                if hasattr(self, metodo):
                    metodos_encontrados.append(metodo)
                    self._log(f"   ‚úÖ {metodo} - DISPONIBLE")
                else:
                    self._log(f"   ‚ùå {metodo} - NO DISPONIBLE")

            self._log(f"üî• M√©todos heredados encontrados: {metodos_encontrados}")
            self._log("üîç === FIN DEBUG M√âTODOS ===")

        except Exception as e:
            self._log(f"‚ùå Error en debug m√©todos: {e}", "error")

    
    
    async def _hacer_clic_cuenta_en_pausa(self, idcuenta: str) -> bool:
        """
        Busca y hace clic en una cuenta espec√≠fica EN LA TABLA EN PAUSA.
        """
        try:
            self._log(f"üîç Buscando cuenta {idcuenta} en tabla EN PAUSA")

            # Esperar expl√≠citamente a que haya al menos una fila en la tabla
            try:
                await self.page.wait_for_selector(self.selectores['filas_tabla_principal'], timeout=20000)
            except Exception as e:
                self._log(f"‚ö†Ô∏è No se encontraron filas en la tabla tras esperar: {e}", "warning")
                return False

            # Recrear el locator de filas justo antes de buscar
            filas = self.page.locator(self.selectores['filas_tabla_principal'])
            total_filas = await filas.count()
            self._log(f"üìä Buscando en {total_filas} filas de tabla EN PAUSA")

            # Imprimir los IDs de todas las filas encontradas
            ids_encontrados = []
            for i in range(total_filas):
                try:
                    fila = filas.nth(i)
                    celdas = fila.locator("td")
                    if await celdas.count() > 0:
                        id_celda = await celdas.nth(0).text_content()
                        id_celda = id_celda.strip()
                        ids_encontrados.append(id_celda)
                except Exception as e:
                    self._log(f"‚ö†Ô∏è Error leyendo fila {i}: {e}", "warning")
                    continue
            self._log(f"üîé IDs encontrados en tabla: {ids_encontrados}")

            # Buscar el ID objetivo
            for i, id_celda in enumerate(ids_encontrados):
                if id_celda == idcuenta:
                    self._log(f"‚úÖ Cuenta {idcuenta} encontrada en fila {i} de EN PAUSA")
                    fila = filas.nth(i)
                    boton_cuenta = fila.locator(self.selectores['boton_cuenta'])
                    if await boton_cuenta.count() > 0:
                        await boton_cuenta.first.scroll_into_view_if_needed()
                        await asyncio.sleep(1)
                        await boton_cuenta.first.click()
                        self._log(f"üñ±Ô∏è Clic realizado en cuenta {idcuenta} EN PAUSA")
                        await self.page.wait_for_load_state('networkidle', timeout=15000)
                        await asyncio.sleep(3)
                        return True
                    else:
                        self._log(f"‚ùå No se encontr√≥ bot√≥n para cuenta {idcuenta} en EN PAUSA", "error")
                        return False

            self._log(f"‚ùå Cuenta {idcuenta} NO encontrada en tabla EN PAUSA", "error")
            return False

        except Exception as e:
            self._log(f"‚ùå Error buscando cuenta {idcuenta} en EN PAUSA: {e}", "error")
            return False
    
    async def _incrementar_intentos(self, idcuenta: str):
        """Incrementa el n√∫mero de intentos para una cuenta."""
        try:
            with self.db_manager.get_connection() as conn:
                conn.execute("""
                    UPDATE cuenta_glosas_principal 
                    SET intentos = COALESCE(intentos, 0) + 1,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE idcuenta = ?
                """, (idcuenta,))
                conn.commit()
                
                self._log(f"üî¢ Intentos incrementados para cuenta {idcuenta}")
                
        except Exception as e:
            self._log(f"‚ùå Error incrementando intentos {idcuenta}: {e}", "error")
    
    async def _marcar_cuenta_procesada(self, idcuenta: str):
        """Marca una cuenta como procesada exitosamente."""
        try:
            self.db_manager.update_cuenta_estado(
                idcuenta, 
                EstadoCuenta.COMPLETADO,
                "Procesada exitosamente en m√≥dulo EN PAUSA"
            )
            self._log(f"‚úÖ Cuenta {idcuenta} marcada como COMPLETADA")
            
        except Exception as e:
            self._log(f"‚ùå Error marcando cuenta como procesada {idcuenta}: {e}", "error")
    
    async def _marcar_cuenta_fallida(self, idcuenta: str, motivo: str):
        """Marca una cuenta como fallida."""
        try:
            self.db_manager.update_cuenta_estado(
                idcuenta, 
                EstadoCuenta.FALLIDO,
                f"Error en procesamiento EN PAUSA: {motivo}"
            )
            self._log(f"‚ùå Cuenta {idcuenta} marcada como FALLIDA: {motivo}")
        except Exception as e:
            self._log(f"‚ùå Error marcando cuenta como procesada {idcuenta}: {e}", "error")
    
    async def extraer_datos_filas_tabla(self) -> List[Dict]:
        """
        Extrae los datos de todas las filas visibles en la tabla EN PAUSA.
        Retorna una lista de diccionarios con los datos de cada cuenta.
        """
        self._log("üìã Extrayendo datos de filas de la tabla EN PAUSA")
        cuentas = []
        try:
            # Ajusta el selector al de la tabla EN PAUSA
            filas = self.page.locator(self.selectores['filas_tabla_principal'])
            total_filas = await filas.count()
            self._log(f"üîé Total filas encontradas en EN PAUSA: {total_filas}")

            for i in range(total_filas):
                fila = filas.nth(i)
                celdas = fila.locator("td")
                if await celdas.count() < 5:
                    continue  # Salta filas incompletas

                # Ajusta los √≠ndices seg√∫n el orden de columnas de la tabla EN PAUSA
                idcuenta = (await celdas.nth(0).text_content() or "").strip()
                proveedor = (await celdas.nth(1).text_content() or "").strip()
                estado = (await celdas.nth(2).text_content() or "").strip()
                valor_glosado = (await celdas.nth(3).text_content() or "").strip()
                fecha_radicacion = (await celdas.nth(4).text_content() or "").strip()
                # Agrega m√°s campos si tu tabla tiene m√°s columnas relevantes

                cuentas.append({
                    "idcuenta": idcuenta,
                    "proveedor": proveedor,
                    "estado": estado,
                    "valor_glosado": valor_glosado,
                    "fecha_radicacion": fecha_radicacion,
                    # ...otros campos si es necesario...
                })
            self._log(f"‚úÖ Extracci√≥n completada. Total cuentas: {len(cuentas)}")
        except Exception as e:
            self._log(f"‚ùå Error extrayendo filas de tabla EN PAUSA: {e}", "error")
        return cuentas
    
    async def procesar_y_guardar_cuentas(self, cuentas_extraidas: List[Dict]):
        """
        ‚úÖ MEJORADO: Guarda las cuentas extra√≠das en la base de datos como PENDIENTE.
        Cambiado de FALLIDO a PENDIENTE para que sean procesables.
        """
        self._log(f"üíæ Guardando {len(cuentas_extraidas)} cuentas EN PAUSA en base de datos como PENDIENTE")
        try:
            cuentas_guardadas = 0

            for cuenta in cuentas_extraidas:
                try:
                    # ‚úÖ VERIFICAR si ya existe para evitar duplicados
                    if self.db_manager.should_process_cuenta(cuenta['idcuenta']):

                        # ‚úÖ USAR el m√©todo correcto del db_manager
                        cuenta_data = {
                            'idcuenta': cuenta['idcuenta'],
                            'proveedor': cuenta['proveedor'],
                            'valor_glosado': self._parsear_moneda(cuenta['valor_glosado']),
                            'fecha_radicacion': cuenta['fecha_radicacion'],
                            'numero_radicacion': '',  # Completar si tienes este dato
                            'numero_factura': '',     # Completar si tienes este dato  
                            'fecha_factura': '',      # Completar si tienes este dato
                            'valor_factura': 0.0      # Completar si tienes este dato
                        }

                        cuenta_bd_id = self.db_manager.create_or_update_cuenta(cuenta_data)
                        cuentas_guardadas += 1

                        if cuentas_guardadas <= 5:  # Log solo primeras 5
                            self._log(f"‚úÖ Cuenta {cuenta['idcuenta']} guardada como PENDIENTE - ID: {cuenta_bd_id}")

                    else:
                        self._log(f"‚è≠Ô∏è Cuenta {cuenta['idcuenta']} saltada (ya procesada o en proceso)")

                except Exception as e:
                    self._log(f"‚ùå Error guardando cuenta {cuenta['idcuenta']}: {e}", "error")
                    continue

            self._log(f"‚úÖ Guardado completado. Total cuentas nuevas guardadas: {cuentas_guardadas}/{len(cuentas_extraidas)}")

            # ‚úÖ EMITIR SIGNAL si hay worker
            if self.worker and cuentas_guardadas > 0:
                self.worker.emit_data_imported(cuentas_guardadas)
                self.worker.emit_tabla_refresh()

        except Exception as e:
            self._log(f"‚ùå Error guardando cuentas en base de datos: {e}", "error")
    async def ejecutar(self):
        """
        ‚úÖ FUNCIONALIDAD RECUPERADA: BD primero, luego importar tabla si es necesario.
        1. Busca cuentas pendientes en BD
        2. Si no hay nada en BD, importa desde tabla web
        3. Procesa lo que encuentra/importa
        """
        self._log("‚ñ∂Ô∏è Iniciando procesamiento de cuentas EN PAUSA (BD PRIMERO)")
        try:
            # ‚úÖ PASO 1: Buscar primero en BD
            self._log("üîç Buscando cuentas pendientes en BD...")
            cuentas_pendientes_bd = await self._obtener_cuentas_en_pausa()

            if cuentas_pendientes_bd:
                # ‚úÖ HAY CUENTAS EN BD: Procesar directamente
                self._log(f"üìã Encontradas {len(cuentas_pendientes_bd)} cuentas pendientes en BD")
                self._log("üöÄ Procesando cuentas existentes en BD...")

                procesadas, fallidas = await self.procesar_cuentas_en_pausa(cuentas_pendientes_bd)
                self._log(f"‚úÖ Procesamiento BD completado - Procesadas: {procesadas}, Fallidas: {fallidas}")

            else:
                # ‚úÖ NO HAY CUENTAS EN BD: Importar desde tabla web
                self._log("‚ö†Ô∏è No hay cuentas pendientes en BD")
                self._log("üì• Importando cuentas desde tabla web EN PAUSA...")

                # Extraer de la tabla web
                cuentas_en_tabla = await self.extraer_datos_filas_tabla()

                if cuentas_en_tabla:
                    self._log(f"üìã Encontradas {len(cuentas_en_tabla)} cuentas en tabla web")

                    # Guardar en BD como PENDIENTE
                    await self.procesar_y_guardar_cuentas(cuentas_en_tabla)
                    self._log("üíæ Cuentas guardadas en BD")

                    # Buscar las reci√©n importadas
                    cuentas_recien_importadas = await self._obtener_cuentas_en_pausa()

                    if cuentas_recien_importadas:
                        self._log(f"üöÄ Procesando {len(cuentas_recien_importadas)} cuentas reci√©n importadas...")
                        procesadas, fallidas = await self.procesar_cuentas_en_pausa(cuentas_recien_importadas)
                        self._log(f"‚úÖ Procesamiento importaci√≥n completado - Procesadas: {procesadas}, Fallidas: {fallidas}")
                    else:
                        self._log("‚ùå Error: No se pudieron recuperar cuentas despu√©s de importar", "error")
                else:
                    self._log("‚ö†Ô∏è No hay cuentas en tabla web para importar")

            self._log("‚úÖ Proceso de cuentas EN PAUSA completado")

        except Exception as e:
            self._log(f"‚ùå Error en el proceso de cuentas EN PAUSA: {e}", "error")
    async def verificar_estado_sistema(self):
        """
        üîç DIAGN√ìSTICO: Verifica el estado actual de BD y tabla web.
        √ötil para debuggear y entender qu√© hay disponible.
        """
        try:
            self._log("üîç === VERIFICANDO ESTADO DEL SISTEMA ===")

            # 1. Verificar BD
            cuentas_bd = await self._obtener_cuentas_en_pausa()
            self._log(f"üìä Cuentas pendientes en BD: {len(cuentas_bd)}")

            if cuentas_bd:
                estados = {}
                for cuenta in cuentas_bd[:5]:  # Solo primeras 5
                    estado = cuenta.get('estado', 'N/A')
                    intentos = cuenta.get('intentos', 0)
                    estados[cuenta['idcuenta']] = f"{estado} ({intentos} intentos)"
                self._log(f"üìã Muestra BD: {estados}")

            # 2. Verificar tabla web
            cuentas_web = await self.extraer_datos_filas_tabla()
            self._log(f"üìä Cuentas en tabla web: {len(cuentas_web)}")

            if cuentas_web:
                muestra_web = {}
                for cuenta in cuentas_web[:5]:  # Solo primeras 5
                    muestra_web[cuenta['idcuenta']] = cuenta.get('estado', 'N/A')
                self._log(f"üìã Muestra Web: {muestra_web}")

            # 3. Recomendaci√≥n
            if cuentas_bd:
                self._log("üí° RECOMENDACI√ìN: Procesar cuentas existentes en BD")
            elif cuentas_web:
                self._log("üí° RECOMENDACI√ìN: Importar cuentas desde tabla web")
            else:
                self._log("‚ö†Ô∏è RECOMENDACI√ìN: No hay cuentas disponibles para procesar")

            self._log("üîç === FIN VERIFICACI√ìN ===")

            return {
                'cuentas_bd': len(cuentas_bd),
                'cuentas_web': len(cuentas_web),
                'tiene_pendientes_bd': len(cuentas_bd) > 0,
                'tiene_tabla_web': len(cuentas_web) > 0
            }

        except Exception as e:
            self._log(f"‚ùå Error verificando estado: {e}", "error")
            return {
                'cuentas_bd': 0,
                'cuentas_web': 0,
                'tiene_pendientes_bd': False,
                'tiene_tabla_web': False
            }
    
    async def _navegar_y_hacer_clic_cuenta(self, idcuenta: str) -> bool:
        """
        ‚úÖ SOBRESCRITO: Detecta si ya estamos en pantalla de glosas.
        Reutiliza _hacer_clic_cuenta_en_pausa() que ya tienes y funciona.
        """
        try:
            url_actual = self.page.url
            self._log(f"üîç _navegar_y_hacer_clic_cuenta EN PAUSA - URL: {url_actual}")

            # ‚úÖ DETECCI√ìN INTELIGENTE: ¬øYa estamos en pantalla de glosas?
            if "respuestaGlosastart" in url_actual:
                self._log(f"‚úÖ YA ESTAMOS en pantalla de glosas para cuenta {idcuenta}")
                self._log("üéØ SALTANDO navegaci√≥n - continuando con procesamiento")
                return True

            # ‚úÖ Si no, usar tu m√©todo existente que YA FUNCIONA
            self._log(f"üìã Usando m√©todo existente _hacer_clic_cuenta_en_pausa")
            return await self._hacer_clic_cuenta_en_pausa(idcuenta)

        except Exception as e:
            self._log(f"‚ùå Error en _navegar_y_hacer_clic_cuenta EN PAUSA: {e}", "error")
            return False
    async def _regresar_tabla_principal(self):
        """REFACTORIZADO: Usar navegaci√≥n directa m√°s simple."""
        try:
            self._log("‚Ü©Ô∏è Regresando a tabla EN PAUSA")
            await self.page.goto(self.url_tabla_principal)
            await self.page.wait_for_load_state('networkidle', timeout=15000)
            await asyncio.sleep(3)
            self._log("‚úÖ Regreso a EN PAUSA exitoso")
            return True
        except Exception as e:
            self._log(f"‚ùå Error regresando a tabla EN PAUSA: {e}", "error")
            return False
    
    async def _marcar_como_fallida_definitiva(self, idcuenta: str, motivo: str):
        """Solo agregar si no existe ya."""
        try:
            self.db_manager.update_cuenta_estado(
                idcuenta, 
                EstadoCuenta.FALLIDO,
                f"Fallida definitiva despu√©s de 5 intentos: {motivo[:200]}"
            )
            self._log(f"üö´ Cuenta {idcuenta} marcada como fallida definitiva")
        except Exception as e:
            self._log(f"‚ùå Error marcando como fallida definitiva {idcuenta}: {e}", "error")

    async def _marcar_error_procesamiento(self, idcuenta: str, error: str):
        """Solo agregar si no existe ya."""
        try:
            self.db_manager.update_cuenta_estado(
                idcuenta, 
                EstadoCuenta.FALLIDO,
                f"Error en procesamiento: {error[:200]}"
            )
        except Exception as e:
            self._log(f"‚ùå Error marcando error de procesamiento {idcuenta}: {e}", "error")
    async def _cargar_configuraciones_respuesta(self):
        """Carga las configuraciones de respuesta desde la BD."""
        try:
            self._log("üìã Cargando configuraciones de respuesta autom√°tica")
            
            with self.db_manager.get_connection() as conn:
                cursor = conn.execute("""
                    SELECT tipo, justificacion_patron, respuesta_automatica, url_pdf
                    FROM glosas_respuestas_config 
                    WHERE activo = 1
                    ORDER BY tipo, justificacion_patron
                """)
                
                self.configuraciones_respuesta = {}
                for row in cursor.fetchall():
                    key = f"{row['tipo']}_{row['justificacion_patron']}"
                    self.configuraciones_respuesta[key] = {
                        'respuesta': row['respuesta_automatica'],
                        'pdf_path': row['url_pdf'],
                        'tipo': row['tipo'],
                        'patron': row['justificacion_patron']
                    }
                
                self._log(f"‚úÖ Cargadas {len(self.configuraciones_respuesta)} configuraciones")
                
        except Exception as e:
            self._log(f"‚ö†Ô∏è Error cargando configuraciones: {e}", "warning")
            self.configuraciones_respuesta = {}

    # ‚úÖ NUEVO: Preparar sistema independiente  
    async def _preparar_sistema(self) -> bool:
        """Prepara el sistema para el procesamiento independiente."""
        try:
            self._log("üîß Preparando sistema independiente para EN PAUSA")

            # Ya tienes _cargar_configuraciones_respuesta() - solo llamarlo
            await self._cargar_configuraciones_respuesta()

            # Usar NavigationHandler para configurar a 500 (ya lo tienes implementado)
            if hasattr(self, 'navigation_handler') and self.navigation_handler:
                # Tu NavigationHandler ya configura EN PAUSA para 500 autom√°ticamente
                self._log("‚úÖ Configuraci√≥n de tabla delegada a NavigationHandler")
            else:
                # Fallback: configurar manualmente para 500 (como ya lo tienes)
                await self._configurar_tabla_500_registros()

            self._log("‚úÖ Sistema independiente preparado")
            return True

        except Exception as e:
            self._log(f"‚ùå Error preparando sistema: {e}", "error")
            return False

    # ‚úÖ NUEVO: Configurar tabla para 500 registros (tu est√°ndar actual)
    async def _configurar_tabla_500_registros(self):
        """Configura la tabla EN PAUSA para mostrar 500 registros (o Todos si no hay 500)."""
        try:
            self._log("üîß Configurando tabla EN PAUSA para 500 registros")
            resultado_js = await self.page.evaluate("""
                () => {
                    const select = document.querySelector('select[name="tablaRespuestaGlosaPause_length"]');
                    if (!select) return { success: false, error: 'Select no encontrado' };
                    const opcion500 = select.querySelector('option[value="500"]');
                    if (opcion500) {
                        select.value = '500';
                        select.dispatchEvent(new Event('change', { bubbles: true }));
                        select.dispatchEvent(new Event('input', { bubbles: true }));
                        return { success: true, valor: '500' };
                    }
                    const opcionTodos = select.querySelector('option[value="-1"]');
                    if (opcionTodos) {
                        select.value = '-1';
                        select.dispatchEvent(new Event('change', { bubbles: true }));
                        select.dispatchEvent(new Event('input', { bubbles: true }));
                        return { success: true, valor: '-1' };
                    }
                    return { success: false, error: 'No hay opci√≥n 500 ni Todos' };
                }
            """)
            if resultado_js.get('success'):
                await self.page.wait_for_load_state('networkidle', timeout=10000)
                await asyncio.sleep(2)
                self._log(f"‚úÖ Tabla EN PAUSA configurada para {resultado_js['valor']} registros")
            else:
                self._log(f"‚ö†Ô∏è No se pudo configurar la tabla: {resultado_js.get('error')}", "warning")
        except Exception as e:
            self._log(f"‚ö†Ô∏è Error configurando tabla: {e}", "warning")

    # ‚úÖ NUEVO: Procesar cuenta completa independiente
    async def _procesar_cuenta_completa_independiente(self, idcuenta: str) -> Dict:
        """Procesa una cuenta completa de forma independiente."""
        try:
            self._log(f"üîÑ Procesando cuenta completa independiente: {idcuenta}")

            # Marcar como EN_PROCESO
            self.db_manager.update_cuenta_estado(
                idcuenta, 
                EstadoCuenta.EN_PROCESO,
                "Iniciando procesamiento independiente EN PAUSA"
            )

            if self.worker:
                self.worker.emit_cuenta_processed(idcuenta, 'EN_PROCESO')

            # Procesar todas las glosas
            resultado_glosas = await self._procesar_todas_las_glosas_cuenta(idcuenta)

            if not resultado_glosas['exito']:
                await self._marcar_cuenta_fallida(idcuenta, f"Error procesando glosas: {resultado_glosas['error']}")
                return resultado_glosas

            # Terminar cuenta
            if not await self._terminar_cuenta():
                await self._marcar_cuenta_fallida(idcuenta, "No se pudo terminar la cuenta")
                return {'exito': False, 'error': 'No se pudo terminar la cuenta'}

            # Marcar como COMPLETADO
            self.db_manager.update_cuenta_estado(
                idcuenta, 
                EstadoCuenta.COMPLETADO,
                f"Procesada independiente EN PAUSA - {resultado_glosas['glosas_procesadas']} glosas"
            )

            return {
                'exito': True,
                'glosas_procesadas': resultado_glosas['glosas_procesadas'],
                'glosas_fallidas': resultado_glosas['glosas_fallidas']
            }

        except Exception as e:
            error_msg = f"Error procesando cuenta independiente {idcuenta}: {e}"
            self._log(error_msg, "error")
            await self._marcar_cuenta_fallida(idcuenta, error_msg)
            return {'exito': False, 'error': error_msg}

    # ‚úÖ NUEVO: Procesar todas las glosas de una cuenta
    async def _procesar_todas_las_glosas_cuenta(self, idcuenta: str) -> Dict:
        """Procesa todas las glosas de una cuenta."""
        try:
            self._log(f"üìã Procesando todas las glosas de cuenta {idcuenta}")

            # Hacer scroll hasta tabla de glosas
            if not await self._hacer_scroll_hasta_tabla_glosas():
                return {'exito': False, 'error': 'No se pudo hacer scroll hasta tabla de glosas'}

            # Extraer glosas de la tabla
            glosas_extraidas = await self._extraer_glosas_de_tabla(idcuenta)

            if not glosas_extraidas:
                return {'exito': False, 'error': 'No se encontraron glosas para procesar'}

            self._log(f"üìä Encontradas {len(glosas_extraidas)} glosas para procesar")

            # Procesar cada glosa
            glosas_procesadas = 0
            glosas_fallidas = 0

            for i, glosa in enumerate(glosas_extraidas):
                self._log(f"   üîÑ Procesando glosa {i+1}/{len(glosas_extraidas)}: {glosa['id_glosa']}")

                try:
                    # Buscar configuraci√≥n
                    tipo_glosa = glosa.get('tipo', '')
                    justificacion_glosa = glosa.get('justificacion', '')
                    configuracion = self._buscar_configuracion_glosa(tipo_glosa, justificacion_glosa)

                    if not configuracion:
                        await self._guardar_glosa_sin_configuracion(idcuenta, glosa)
                        self._log(f"   ‚ö†Ô∏è Glosa {glosa['id_glosa']}: SIN configuraci√≥n")
                        continue

                    # Procesar glosa
                    glosa['configuracion'] = configuracion
                    resultado = await self._procesar_glosa_individual(glosa)

                    if resultado['exito']:
                        glosas_procesadas += 1
                        self._log(f"   ‚úÖ Glosa {glosa['id_glosa']} procesada exitosamente")
                    else:
                        glosas_fallidas += 1
                        self._log(f"   ‚ùå Glosa {glosa['id_glosa']} fall√≥")

                except Exception as e:
                    glosas_fallidas += 1
                    self._log(f"   ‚ùå Error procesando glosa {glosa['id_glosa']}: {e}", "error")

                await asyncio.sleep(2)

            return {
                'exito': True,
                'glosas_procesadas': glosas_procesadas,
                'glosas_fallidas': glosas_fallidas
            }

        except Exception as e:
            error_msg = f"Error procesando glosas de cuenta {idcuenta}: {e}"
            self._log(error_msg, "error")
            return {'exito': False, 'error': error_msg}

    # ‚úÖ NUEVO: Hacer scroll hasta tabla de glosas
    async def _hacer_scroll_hasta_tabla_glosas(self) -> bool:
        """Hace scroll hasta la tabla de glosas."""
        try:
            # Buscar tabla de glosas
            tabla_glosas = self.page.locator("#tableAuditGlosas")
            if await tabla_glosas.count() > 0:
                await tabla_glosas.scroll_into_view_if_needed()
                await asyncio.sleep(2)
                self._log("‚úÖ Scroll hasta tabla de glosas realizado")
                return True

            # Fallback: scroll general
            await self.page.evaluate("window.scrollTo(0, document.body.scrollHeight * 0.7)")
            await asyncio.sleep(3)
            return True

        except Exception as e:
            self._log(f"‚ö†Ô∏è Error haciendo scroll: {e}", "warning")
            return False

    # ‚úÖ NUEVO: Extraer glosas de la tabla
    async def _extraer_glosas_de_tabla(self, idcuenta: str) -> List[Dict]:
        """Extrae informaci√≥n de todas las glosas de la tabla."""
        try:
            glosas = []
            filas = self.page.locator("#tableAuditGlosas tbody tr")
            total_filas = await filas.count()

            if total_filas == 0:
                self._log("‚ùå No se encontr√≥ tabla de glosas", "error")
                return []

            self._log(f"üìä Extrayendo {total_filas} glosas de la tabla")

            for i in range(total_filas):
                try:
                    fila = filas.nth(i)
                    celdas = fila.locator("td")
                    total_celdas = await celdas.count()

                    if total_celdas >= 8:
                        glosa_info = {
                            'id_glosa': await celdas.nth(0).text_content() or "",
                            'id_item': await celdas.nth(1).text_content() or "",
                            'descripcion_item': await celdas.nth(2).text_content() or "",
                            'tipo': await celdas.nth(3).text_content() or "",
                            'descripcion': await celdas.nth(4).text_content() or "",
                            'justificacion': await celdas.nth(5).text_content() or "",
                            'valor_glosado': await celdas.nth(6).text_content() or "",
                            'estado': await celdas.nth(7).text_content() or "",
                            'idcuenta': idcuenta
                        }

                        # Limpiar datos
                        for key, value in glosa_info.items():
                            if isinstance(value, str):
                                glosa_info[key] = value.strip()

                        # Guardar en BD usando m√©todo que ya tienes
                        cuenta_id = await self._obtener_cuenta_id(idcuenta)
                        if cuenta_id:
                            self._guardar_glosa_en_detalle(cuenta_id, glosa_info)

                        glosas.append(glosa_info)

                except Exception as e:
                    self._log(f"‚ö†Ô∏è Error extrayendo glosa en fila {i}: {e}", "warning")
                    continue
                
            self._log(f"üìä Extracci√≥n completada: {len(glosas)} glosas")
            return glosas

        except Exception as e:
            self._log(f"‚ùå Error extrayendo glosas de tabla: {e}", "error")
            return []

    # ‚úÖ NUEVO: Buscar configuraci√≥n para glosa
    def _buscar_configuracion_glosa(self, tipo: str, justificacion: str) -> Optional[Dict]:
        """Busca configuraci√≥n para una glosa espec√≠fica."""
        try:
            for key, config in self.configuraciones_respuesta.items():
                if config['tipo'].upper() == tipo.upper():
                    patron = config['patron'].replace('%', '').upper()
                    if patron in justificacion.upper():
                        return config
            return None
        except Exception as e:
            self._log(f"‚ùå Error buscando configuraci√≥n: {e}", "error")
            return None

    # ‚úÖ NUEVO: Procesar glosa individual
    async def _procesar_glosa_individual(self, glosa_info: Dict) -> Dict:
        """Procesa una glosa individual."""
        try:
            id_glosa = glosa_info.get('id_glosa', '')

            # Hacer clic en bot√≥n de la glosa
            if not await self._hacer_clic_boton_glosa(id_glosa):
                return {'exito': False, 'error': 'No se pudo hacer clic en bot√≥n de glosa'}

            # Esperar que el modal se abra
            if not await self._esperar_modal_abierto(id_glosa):
                return {'exito': False, 'error': 'Modal no se abri√≥ correctamente'}

            # Llenar modal
            configuracion = glosa_info.get('configuracion')
            if not configuracion:
                await self._cerrar_modal()
                return {'exito': False, 'error': 'Sin configuraci√≥n disponible'}

            if not await self._llenar_modal_respuesta(configuracion, glosa_info):
                await self._cerrar_modal()
                return {'exito': False, 'error': 'Error llenando modal'}

            # Guardar respuesta
            if not await self._guardar_respuesta_modal():
                await self._cerrar_modal()
                return {'exito': False, 'error': 'Error guardando respuesta'}

            await asyncio.sleep(3)
            await self._guardar_glosa_procesada(glosa_info.get('idcuenta', ''), glosa_info, configuracion)
            return {'exito': True}

        except Exception as e:
            try:
                await self._cerrar_modal()
            except:
                pass
            await self._guardar_glosa_fallida(glosa_info.get('idcuenta', ''), glosa_info, str(e))
            return {'exito': False, 'error': str(e)}

    # ‚úÖ NUEVO: Hacer clic en bot√≥n de glosa
    async def _hacer_clic_boton_glosa(self, id_glosa: str) -> bool:
        """Hace clic en el bot√≥n de una glosa espec√≠fica."""
        try:
            boton_glosa = self.page.locator(f'button.btnAnswerGlosaModal[idglosa="{id_glosa}"]')
            if await boton_glosa.count() > 0:
                await boton_glosa.scroll_into_view_if_needed()
                await asyncio.sleep(1)
                await boton_glosa.click()
                return True
            return False
        except Exception as e:
            self._log(f"‚ùå Error haciendo clic en bot√≥n glosa {id_glosa}: {e}", "error")
            return False

    # ‚úÖ NUEVO: Esperar modal abierto
    async def _esperar_modal_abierto(self, id_glosa: str) -> bool:
        """Espera a que el modal se abra correctamente."""
        try:
            titulo_modal = self.page.locator("#titleModalAnswerGlosa")
            await titulo_modal.wait_for(state="visible", timeout=10000)
            await asyncio.sleep(2)
            return True
        except Exception as e:
            self._log(f"‚ùå Error esperando modal para glosa {id_glosa}: {e}", "error")
            return False

    # ‚úÖ NUEVO: Llenar modal de respuesta
    async def _llenar_modal_respuesta(self, configuracion: Dict, glosa_info: Dict) -> bool:
        """Llena el modal de respuesta, validando existencia de PDF seg√∫n configuraci√≥n."""
        try:
            self._log("üü¢ [PDF] Iniciando llenado de modal de respuesta")

            # Seleccionar dropdown
            self._log("üü¢ [PDF] Seleccionando respuesta en dropdown...")
            if not await self._seleccionar_respuesta_dropdown():
                self._log("üî¥ [PDF] Fall√≥ selecci√≥n de respuesta en dropdown")
                return False

            # Llenar justificaci√≥n
            self._log("üü¢ [PDF] Llenando justificaci√≥n...")
            if not await self._llenar_justificacion(configuracion['respuesta']):
                self._log("üî¥ [PDF] Fall√≥ llenado de justificaci√≥n")
                return False

            pdf_path = configuracion.get('pdf_path', '')
            tipo = glosa_info.get('tipo', '')
            num_factura = glosa_info.get('num_factura', '')
            idcuenta = glosa_info.get('idcuenta', '')

            # Si NO hay ruta PDF configurada, procesa sin subir PDF
            if not pdf_path:
                self._log("üü° [PDF] No hay ruta PDF configurada, procesando sin subir PDF")
                self._log("‚úÖ Modal llenado correctamente (sin PDF)")
                return True

            # Si es AUTORIZACION, ajusta la ruta
            if tipo.upper() == "AUTORIZACION" and num_factura:
                ruta_final = os.path.normpath(os.path.join(pdf_path, num_factura, "OTROS.PDF"))
                self._log(f"üü¢ [PDF] Ruta PDF ajustada por AUTORIZACION: {ruta_final}")
            else:
                ruta_final = os.path.normpath(pdf_path)
                self._log(f"üü¢ [PDF] Ruta PDF a usar: {ruta_final}")

            # Si hay ruta PDF y el archivo NO existe, marca como fallida y retorna False
            if not os.path.exists(ruta_final):
                self._log(f"üî¥ [PDF] PDF no encontrado: {ruta_final}", "error")
                await self._guardar_glosa_fallida(idcuenta, glosa_info, f"PDF no encontrado: {ruta_final}")
                await self._marcar_cuenta_fallida(idcuenta, f"PDF no encontrado: {ruta_final}")
                self._log("üî¥ [PDF] Glosa y cuenta marcadas como fallidas por falta de PDF")
                return False

            # Si existe, sube el archivo
            self._log(f"üü¢ [PDF] Subiendo archivo PDF: {ruta_final}")
            if not await self._subir_archivo_pdf(ruta_final):
                self._log("üî¥ [PDF] Fall√≥ la subida del archivo PDF")
                return False

            self._log("‚úÖ Modal llenado correctamente (con PDF)")
            return True
        except Exception as e:
            self._log(f"‚ùå Error llenando modal: {e}", "error")
            return False

    # ‚úÖ NUEVO: Seleccionar respuesta en dropdown
    async def _seleccionar_respuesta_dropdown(self) -> bool:
        """Selecciona la respuesta en el dropdown."""
        try:
            select2_container = self.page.locator("#select2-glosaRespTipo-container")
            await select2_container.click()
            await asyncio.sleep(2)

            opcion_999 = self.page.locator("li.select2-results__option:has-text('999 SUBSANADA')")
            await opcion_999.first.click()
            await asyncio.sleep(1)
            return True
        except Exception as e:
            self._log(f"‚ùå Error seleccionando dropdown: {e}", "error")
            return False

    # ‚úÖ NUEVO: Llenar justificaci√≥n
    async def _llenar_justificacion(self, respuesta_texto: str) -> bool:
        """
        ‚úÖ MEJORADO: Llena el campo de justificaci√≥n simulando escritura humana.
        Copiado desde ProcesadorCompletoGlosasImplementado con simulaci√≥n de espacios.
        """
        try:
            texto_mayuscula = respuesta_texto.upper()
            textarea = self.page.locator(self.selectores['textarea_justificacion'])
            await textarea.scroll_into_view_if_needed()
            await textarea.click()
            await asyncio.sleep(0.5)

            # Limpiar campo completamente
            await textarea.press('Control+a')
            await textarea.press('Delete')
            await asyncio.sleep(0.5)

            # Pegar texto con JS
            self._log("üìã Pegando texto de la base de datos...")
            await self.page.evaluate("""
                (texto) => {
                    const textarea = document.getElementById('glosaRespObs');
                    if (textarea) {
                        textarea.value = texto;
                        textarea.focus();
                        textarea.dispatchEvent(new Event('input', { bubbles: true }));
                        textarea.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                }
            """, texto_mayuscula)
            await asyncio.sleep(0.3)

            # Simulaci√≥n humana: espacios al final
            self._log("üìù Agregando espacios finales...")
            await textarea.press_sequentially("   ", delay=120)
            await asyncio.sleep(0.2)

            # Simular Tab para salir del campo
            await textarea.press('Tab')
            await asyncio.sleep(1)

            # Verificar resultado
            clases = await textarea.get_attribute('class')
            if clases and 'is-valid' in clases:
                self._log("‚úÖ Justificaci√≥n llenada correctamente")
                return True
            elif not clases or 'is-invalid' not in clases:
                self._log("‚úÖ Justificaci√≥n llenada (estado neutro)")
                return True
            else:
                # Fallback JS
                self._log("üîÑ Aplicando fallback con JavaScript...")
                await self.page.evaluate("""
                    (texto) => {
                        const textarea = document.getElementById('glosaRespObs');
                        if (textarea) {
                            textarea.value = texto;
                            textarea.focus();
                            textarea.dispatchEvent(new Event('input', { bubbles: true }));
                            textarea.dispatchEvent(new Event('change', { bubbles: true }));
                            textarea.dispatchEvent(new Event('blur', { bubbles: true }));
                            textarea.classList.remove('is-invalid');
                            textarea.classList.add('is-valid');
                            const errorMsg = document.getElementById('glosaRespObsHelp');
                            if errorMsg) errorMsg.style.display = 'none';
                        }
                    }
                """, texto_mayuscula)
                self._log("‚úÖ Justificaci√≥n llenada con JavaScript")
                return True

        except Exception as e:
            self._log(f"‚ùå Error llenando justificaci√≥n: {e}", "error")
            return False

    # ‚úÖ NUEVO: Subir archivo PDF
    async def _subir_archivo_pdf(self, pdf_path: str) -> bool:
        """Sube el archivo PDF."""
        try:
            input_file = self.page.locator("#glosaRespFile")
            if await input_file.count() > 0:
                await input_file.set_input_files(pdf_path)
                await asyncio.sleep(2)
            return True
        except Exception as e:
            self._log(f"‚ö†Ô∏è Error subiendo PDF: {e}", "warning")
            return True

    # ‚úÖ NUEVO: Guardar respuesta del modal
    async def _guardar_respuesta_modal(self) -> bool:
        """Hace clic en el bot√≥n para guardar la respuesta."""
        try:
            boton_responder = self.page.locator("#btnAnswerGlosa")
            await boton_responder.scroll_into_view_if_needed()
            await boton_responder.click()
            return True
        except Exception as e:
            self._log(f"‚ùå Error guardando respuesta: {e}", "error")
            return False

    # ‚úÖ NUEVO: Terminar cuenta
    async def _terminar_cuenta(self) -> bool:
        """Termina el procesamiento de la cuenta."""
        try:
            await self.page.evaluate("window.scrollTo(0, document.body.scrollHeight)")
            await asyncio.sleep(2)

            boton_terminar = self.page.locator("#btRespuestaFinish").filter(has_not=self.page.locator('[disabled]'))
            if await boton_terminar.count() > 0:
                await boton_terminar.click()
                await asyncio.sleep(3)

                # Confirmar
                boton_confirmar = self.page.locator(".swal2-confirm")
                await boton_confirmar.wait_for(state="visible", timeout=10000)
                await boton_confirmar.click()
                await asyncio.sleep(2)

                await self.page.wait_for_load_state('networkidle', timeout=15000)
                return True
            return False
        except Exception as e:
            self._log(f"‚ùå Error terminando cuenta: {e}", "error")
            return False

    # ‚úÖ NUEVO: Cerrar modal
    async def _cerrar_modal(self) -> bool:
        """Cierra el modal."""
        try:
            await self.page.keyboard.press('Escape')
            await asyncio.sleep(1)
            return True
        except:
            return False

    # =========================== M√âTODOS DE BASE DE DATOS (NUEVOS) ===========================

    # ‚úÖ NUEVO: Obtener ID de cuenta
    async def _obtener_cuenta_id(self, idcuenta: str) -> Optional[int]:
        """Obtiene el ID interno de la cuenta desde la BD."""
        try:
            with self.db_manager.get_connection() as conn:
                cursor = conn.execute("SELECT id FROM cuenta_glosas_principal WHERE idcuenta = ?", (idcuenta,))
                row = cursor.fetchone()
                return row['id'] if row else None
        except Exception as e:
            self._log(f"‚ùå Error obteniendo ID de cuenta: {e}", "error")
            return None

    # ‚úÖ NUEVO: Guardar glosa en detalle
    def _guardar_glosa_en_detalle(self, cuenta_id: int, glosa_info: Dict):
        """Guarda una glosa en la tabla de detalle."""
        try:
            with self.db_manager.get_connection() as conn:
                cursor = conn.execute("""
                    SELECT id FROM glosa_items_detalle 
                    WHERE cuenta_principal_id = ? AND id_glosa = ?
                """, (cuenta_id, glosa_info.get('id_glosa', '')))

                if cursor.fetchone():
                    # Actualizar
                    conn.execute("""
                        UPDATE glosa_items_detalle 
                        SET tipo = ?, justificacion = ?, valor_glosado = ?, 
                            estado_original = ?, updated_at = CURRENT_TIMESTAMP
                        WHERE cuenta_principal_id = ? AND id_glosa = ?
                    """, (
                        glosa_info.get('tipo', ''),
                        glosa_info.get('justificacion', ''),
                        self._parsear_moneda(glosa_info.get('valor_glosado', '0')),
                        glosa_info.get('estado', 'SIN RESPUESTA'),
                        cuenta_id,
                        glosa_info['id_glosa']
                    ))
                else:
                    # Insertar nueva
                    conn.execute("""
                        INSERT INTO glosa_items_detalle 
                        (cuenta_principal_id, id_glosa, tipo, justificacion, valor_glosado, 
                         estado_original, created_at)
                        VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
                    """, (
                        cuenta_id,
                        glosa_info.get('id_glosa', ''),
                        glosa_info.get('tipo', ''),
                        glosa_info.get('justificacion', ''),
                        self._parsear_moneda(glosa_info.get('valor_glosado', '0')),
                        glosa_info.get('estado', 'SIN RESPUESTA')
                    ))

                conn.commit()

        except Exception as e:
            self._log(f"‚ùå Error guardando glosa en detalle: {e}", "error")

    # ‚úÖ NUEVO: Parsear moneda
    def _parsear_moneda(self, valor: str) -> float:
        """Convierte texto de moneda a float."""
        try:
            if not valor:
                return 0.0
            limpio = valor.replace('$', '').replace(',', '').replace(' ', '').strip()
            return float(limpio) if limpio else 0.0
        except Exception as e:
            self._log(f"‚ö†Ô∏è Error parseando moneda '{valor}': {e}", "warning")
            return 0.0

    # ‚úÖ NUEVO: Guardar glosa procesada
    async def _guardar_glosa_procesada(self, idcuenta: str, glosa_info: Dict, configuracion: Dict):
        """Guarda una glosa como procesada."""
        try:
            cuenta_id = await self._obtener_cuenta_id(idcuenta)
            if not cuenta_id:
                return
    
            with self.db_manager.get_connection() as conn:
                cursor = conn.execute("""
                    SELECT 1 FROM glosas_detalles_procesadas WHERE idcuenta = ? AND id_glosa = ?
                """, (idcuenta, glosa_info['id_glosa']))
                if cursor.fetchone():
                    # Ya existe, actualiza el estado
                    conn.execute("""
                        UPDATE glosas_detalles_procesadas
                        SET estado_procesamiento = 'EXITOSO'
                        WHERE idcuenta = ? AND id_glosa = ?
                    """, (idcuenta, glosa_info['id_glosa']))
                else:
                    # No existe, inserta nuevo
                    conn.execute("""
                        INSERT INTO glosas_detalles_procesadas 
                        (idcuenta, id_glosa, estado_procesamiento)
                        VALUES (?, ?, 'EXITOSO')
                    """, (idcuenta, glosa_info['id_glosa']))
    
                # Actualizar detalle
                conn.execute("""
                    UPDATE glosa_items_detalle
                    SET fue_procesado = TRUE, fecha_procesamiento = CURRENT_TIMESTAMP
                    WHERE cuenta_principal_id = ? AND id_glosa = ?
                """, (cuenta_id, glosa_info.get('id_glosa', '')))
    
                conn.commit()
    
        except Exception as e:
            self._log(f"‚ö†Ô∏è Error guardando glosa procesada: {e}", "warning")
    # ‚úÖ NUEVO: Guardar glosa fallida
    async def _guardar_glosa_fallida(self, idcuenta: str, glosa_info: Dict, error: str):
        """Guarda una glosa como fallida."""
        try:
            cuenta_id = await self._obtener_cuenta_id(idcuenta)
            if not cuenta_id:
                return
    
            with self.db_manager.get_connection() as conn:
                conn.execute("""
                    INSERT INTO glosas_detalles_procesadas 
                    (idcuenta, id_glosa, estado_procesamiento, error_mensaje)
                    VALUES (?, ?, 'ERROR', ?)
                """, (idcuenta, glosa_info['id_glosa'], error))
    
                conn.execute("""
                    UPDATE glosa_items_detalle 
                    SET error_procesamiento = ?, fecha_procesamiento = CURRENT_TIMESTAMP
                    WHERE cuenta_principal_id = ? AND id_glosa = ?
                """, (error, cuenta_id, glosa_info['id_glosa']))
    
                conn.commit()
    
        except Exception as e:
            self._log(f"‚ö†Ô∏è Error guardando glosa fallida: {e}", "warning")

    # ‚úÖ NUEVO: Guardar glosa sin configuraci√≥n
    async def _guardar_glosa_sin_configuracion(self, idcuenta: str, glosa_info: Dict):
        """Guarda una glosa como sin configuraci√≥n."""
        try:
            cuenta_id = await self._obtener_cuenta_id(idcuenta)
            if not cuenta_id:
                return

            with self.db_manager.get_connection() as conn:
                conn.execute("""
                    UPDATE glosa_items_detalle 
                    SET error_procesamiento = 'SIN_CONFIGURACION',
                        fecha_procesamiento = CURRENT_TIMESTAMP
                    WHERE cuenta_principal_id = ? AND id_glosa = ?
                """, (cuenta_id, glosa_info['id_glosa']))

                conn.commit()

        except Exception as e:
            self._log(f"‚ùå Error guardando glosa sin configuraci√≥n: {e}", "error")

    # ‚úÖ NUEVO: Obtener cuentas EN PAUSA desde BD
    async def _obtener_cuentas_en_pausa(self) -> List[Dict]:
        """Obtiene cuentas EN PAUSA desde la base de datos."""
        try:
            self._log("üü¢üü¢üü¢ ENTRANDO a _obtener_cuentas_en_pausa", "info")
            self._log(f"üü¢ Stack trace:\n{''.join(traceback.format_stack(limit=5))}", "info")
            self._log("üìã Obteniendo cuentas EN PAUSA desde BD")

            with self.db_manager.get_connection() as conn:
                cursor = conn.execute("""
                    SELECT idcuenta, proveedor, estado, valor_glosado, fecha_radicacion, 
                           COALESCE(intentos, 0) as intentos
                    FROM cuenta_glosas_principal 
                    WHERE estado IN ('PENDIENTE', 'FALLIDO') 
                    AND COALESCE(intentos, 0) < 5
                    ORDER BY created_at ASC
                """)

                cuentas = []
                for row in cursor.fetchall():
                    cuentas.append({
                        'idcuenta': row['idcuenta'],
                        'proveedor': row['proveedor'],
                        'estado': row['estado'],
                        'valor_glosado': row['valor_glosado'],
                        'fecha_radicacion': row['fecha_radicacion'],
                        'intentos': row['intentos']
                    })

                if cuentas:
                    self._log(f"‚úÖ Encontradas {len(cuentas)} cuentas EN PAUSA")
                    # Imprime la informaci√≥n de las cuentas encontradas (solo primeras 5 para no saturar el log)
                    self._log(f"üîé Primeras cuentas encontradas: {cuentas[:5]}")
                else:
                    self._log("‚ö†Ô∏è No se encontraron cuentas EN PAUSA en la BD")
                return cuentas

        except Exception as e:
            self._log(f"‚ùå Error obteniendo cuentas EN PAUSA desde BD: {e}", "error")
            return []